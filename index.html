<!-- текущий код -->
<!-- структурированный код с застреваниями -->
<!DOCTYPE html>
<html>

<head>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    #canvas {
      background-color: #f8f8f8;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>

<body>
  <canvas id="canvas" width="800" height="600"></canvas>

  <script>
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    let keysPressed = {};
    let seats = new Array(200).fill(false);
    let spectators = [];

    let hero = {
      x: canvas.width - 245,
      y: 350,
      radius: 8,
      speed: 2,
    };

    let enemy = null;

    function createEnemy() {
      enemy = {
        x: 250,
        y: 250,
        radius: 8,
        speed: 1.5,
        color: "#000000",
      };
    }

    function drawSeats(startX, startY, rows, cols) {
      let seatWidth = 15;
      let seatHeight = 15;
      let seatGap = 5; // Промежуток между сидениями
      let rowGap = seatHeight; // Промежуток между рядами

      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (!seats[i * cols + j]) {
            ctx.fillStyle = "#c0c0c0";
          } else {
            ctx.fillStyle = "#006400";
          }
          let x = startX + j * (seatWidth + seatGap);
          let y = startY + i * (seatHeight + seatGap + rowGap);
          ctx.fillRect(x, y, seatWidth, seatHeight);
        }
      }
    }

    function findFreeSeat() {
      const availableSeatsIndices = seats
        .map((taken, index) => ({ taken, index }))
        .filter((seat) => !seat.taken)
        .map((seat) => seat.index);

      if (availableSeatsIndices.length === 0) {
        return -1; // Если свободных мест нет, возвращаем -1
      }

      // Возвращаем случайный индекс из списка свободных мест
      const randomIndex = Math.floor(
        Math.random() * availableSeatsIndices.length
      );
      return availableSeatsIndices[randomIndex];
    }

    function drawStage(x, y, width, height) {
      ctx.fillStyle = "#444444";
      ctx.fillRect(x, y, width, height);
    }

    function drawEntrance(x, y, width, height) {
      ctx.fillStyle = "#778899";
      ctx.fillRect(x, y, width, height);
    }

    function drawSpectators() {
      spectators.forEach((spectator) => {
        ctx.fillStyle = spectator.color;
        ctx.beginPath();
        ctx.arc(
          spectator.x,
          spectator.y,
          spectator.radius,
          0,
          Math.PI * 2,
          true
        );
        ctx.fill();
      });
    }

    function drawHero() {
      ctx.fillStyle = "#0000FF";
      ctx.beginPath();
      ctx.arc(hero.x, hero.y, hero.radius, 0, Math.PI * 2, true);
      ctx.fill();
    }

    function drawEnemy() {
      if (enemy) {
        ctx.fillStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    let potentialSpectators = []; // Массив для зрителей, ожидающих появления
    let spectatorInterval; // Будем хранить ссылку на интервал
    let spectatorIdCounter = 0; // Счетчик для уникальных идентификаторов зрителей

    function initializeSpectators() {
      let entranceX = canvas.width - 20;

      let upperEntranceY = 250; // Высота на холсте для верхнего входа.
      let lowerEntranceY = canvas.height - 60; // Высота на холсте для нижнего входа.
      // Инициализируем потенциальных зрителей
      if (findFreeSeat() !== -1) {
        for (let i = 0; i < 180; i++) {
          let y = i % 2 === 0 ? upperEntranceY : lowerEntranceY;
          potentialSpectators.push({
            id: spectatorIdCounter++,
            x: entranceX,
            y: y,
            radius: 8,
            color: "orange",
            speed: Math.random() * 2 + 1,
            targetSeat: -1,
            isSeated: false,
          });
        }
      } else {
        console.log("Все места заняты, новые зрители не добавлены.");
      }

      // Настройка интервала для добавления зрителей на сцену
      if (spectatorInterval) {
        clearInterval(spectatorInterval); // Сброс существующего интервала, если он есть
      }
      spectatorInterval = setInterval(() => {
        if (potentialSpectators.length > 0) {
          let nextSpectator = potentialSpectators.shift(); // Извлекаем следующего зрителя

          // Устанавливаем цель для зрителя только тогда, когда он появляется
          nextSpectator.targetSeat = findFreeSeat();
          spectators.push(nextSpectator); // Добавляем зрителя в активные
        } else {
          clearInterval(spectatorInterval); // Отменяем интервал, если зрители закончились
        }
      }, 1000); // Добавляем нового зрителя каждую секунду
    }

    function drawScene() {
      // Отрисовка фона и других элементов сцены
      drawStage(100, 50, 600, 100);
      drawSeats(100, 200, 10, 20);
      drawEntrance(canvas.width - 30, 250, 15, 35); // Верхний вход
      drawEntrance(canvas.width - 30, canvas.height - 50, 15, 35); // Нижний вход

      // Отрисовка зрителей
      drawSpectators();

      // Отрисовка героя и врага
      drawHero();
      drawEnemy();

      // Отрисовка счетчиков и других элементов интерфейса
      ctx.fillStyle = "#000";
      ctx.font = "20px Arial";
      ctx.fillText(`Collided: ${collidedSpectators}`, 10, 20);
      ctx.fillText(`Non-collided: ${nonCollidedSpectators}`, 10, 40);
      ctx.fillText(`Hero Collisions: ${heroCollisionCounter}`, 10, 60);
    }

    // function checkCollisionWithHero(spectator) {
    //   // Проверяем, пересекаются ли круги (герой и зритель) используя теорему Пифагора
    //   let dx = hero.x - spectator.x;
    //   let dy = hero.y - spectator.y;
    //   let distance = Math.sqrt(dx * dx + dy * dy);

    //   // Если расстояние между центрами кругов меньше суммы радиусов, произошла коллизия
    //   return distance < hero.radius + spectator.radius;
    // }
    function checkCollisionWithHero(spectator) {
      // Проверяем, пересекается ли зритель с героем
      let dx = hero.x - spectator.x;
      let dy = hero.y - spectator.y;
      let distance = Math.sqrt(dx * dx + dy * dy);

      // Если расстояние между центрами кругов меньше суммы их радиусов, произошла коллизия
      let isColliding = distance < hero.radius + spectator.radius;

      // Если произошла коллизия, и зритель еще не был отмечен как вошедший в коллизию, увеличиваем счетчик и отмечаем его
      if (isColliding && !spectator.hasCollided) {
        spectator.hasCollided = true; // Помечаем зрителя как вошедшего в коллизию
        return true; // Возвращаем true, чтобы указать, что произошла коллизия
      }

      return false; // Если коллизии не произошло или зритель уже был отмечен, возвращаем false
    }

    function checkCollisionWithEnemy(hero, enemy) {
      let dx = hero.x - enemy.x;
      let dy = hero.y - enemy.y;
      let distance = Math.sqrt(dx * dx + dy * dy);

      // Если расстояние между центрами кругов меньше суммы их радиусов, значит, произошла коллизия
      return distance < hero.radius + enemy.radius;
    }

    let collidedSpectators = 0;
    let nonCollidedSpectators = 0;
    let heroCollisionCounter = 600;
    let startX = 100; // X координата начала строчки сидений
    let startY = 200; // Y координата начала строчки сидений

    // function updateSpectators() {
    //   spectators.forEach((spectator) => {
    //     if (!spectator.isSeated) {
    //       if (spectator.targetSeat === -1) {
    //         spectator.targetSeat = findFreeSeat();
    //       } else {
    //         let seatWidth = 15;
    //         let seatHeight = 15;
    //         let seatGap = 5; // Промежуток между сидениями
    //         let rowGap = seatHeight; // Промежуток между рядами

    //         let targetRow = Math.floor(spectator.targetSeat / 20);
    //         let targetCol = spectator.targetSeat % 20;
    //         let targetX = startX + targetCol * (seatWidth + seatGap);
    //         let targetY =
    //           startY + targetRow * (seatHeight + seatGap + rowGap);

    //         if (Math.abs(spectator.x - targetX) > spectator.speed) {
    //           spectator.x +=
    //             Math.sign(targetX - spectator.x) * spectator.speed;
    //         }
    //         if (Math.abs(spectator.y - targetY) > spectator.speed) {
    //           spectator.y +=
    //             Math.sign(targetY - spectator.y) * spectator.speed;
    //         }
    //         spectator.y += (Math.random() - 0.5) * 5;

    //         // Проверяем коллизию с врагом
    //         if (enemy && checkCollisionWithEnemy(spectator, enemy)) {
    //           spectator.color = "red"; // Если есть коллизия с врагом, перекрашиваем зрителя в красный
    //         }

    //         if (
    //           Math.abs(spectator.x - targetX) < 3 &&
    //           Math.abs(spectator.y - targetY) < 3
    //         ) {
    //           seats[spectator.targetSeat] = true; // Место занято
    //           spectator.isSeated = true; // Зритель сел

    //           // Проверяем коллизию при занятии места
    //           if (checkCollisionWithHero(spectator)) {
    //             spectator.color = "green"; // При коллизии перекрашиваем зрителя в зеленый
    //             collidedSpectators++; // Увеличиваем счетчик вошедших в коллизию зрителей
    //           } else {
    //             nonCollidedSpectators++; // Увеличиваем счетчик не вошедших в коллизию зрителей
    //           }
    //         }
    //       }
    //     }
    //   });
    // }
    // function updateSpectators() {
    //   spectators.forEach((spectator) => {
    //     // Обрабатываем только зрителей, которые еще не заняли места
    //     if (!spectator.isSeated) {
    //       if (spectator.targetSeat === -1) {
    //         spectator.targetSeat = findFreeSeat();
    //       } else {
    //         let seatWidth = 15;
    //         let seatHeight = 15;
    //         let seatGap = 5; // Промежуток между сидениями
    //         let rowGap = seatHeight; // Промежуток между рядами

    //         let targetRow = Math.floor(spectator.targetSeat / 20);
    //         let targetCol = spectator.targetSeat % 20;
    //         let targetX = startX + targetCol * (seatWidth + seatGap);
    //         let targetY = startY + targetRow * (seatHeight + seatGap + rowGap);

    //         if (Math.abs(spectator.x - targetX) > spectator.speed) {
    //           spectator.x += Math.sign(targetX - spectator.x) * spectator.speed;
    //         }
    //         if (Math.abs(spectator.y - targetY) > spectator.speed) {
    //           spectator.y += Math.sign(targetY - spectator.y) * spectator.speed;
    //         }

    //         // Условие для проверки, достиг ли зритель своего места
    //         if (
    //           Math.abs(spectator.x - targetX) < 3 &&
    //           Math.abs(spectator.y - targetY) < 3
    //         ) {
    //           spectator.isSeated = true; // Зритель занимает место
    //           seats[spectator.targetSeat] = true; // Место теперь занято

    //           // Если зритель в зеленом (уже произошла коллизия с героем ранее), 
    //           // учитываем только в collidedSpectators
    //           if (spectator.color === "green") {
    //             collidedSpectators++; // Увеличиваем счетчик зрителей в коллизии
    //           } else {
    //             // Проверяем коллизию при занятии места
    //             if (checkCollisionWithHero(spectator)) {
    //               spectator.color = "green"; // При коллизии перекрашиваем зрителя в зеленый
    //               // collidedSpectators++; // Увеличиваем счетчик зрителей в коллизии
    //             } else {
    //               nonCollidedSpectators++; // Увеличиваем счетчик зрителей, не вошедших в коллизию
    //             }
    //           }
    //         }
    //       }
    //     }
    //   });
    // }
    function updateSpectators() {
      spectators.forEach((spectator) => {
        // Обрабатываем только зрителей, которые еще не заняли места
        if (!spectator.isSeated) {
          if (spectator.targetSeat === -1) {
            spectator.targetSeat = findFreeSeat();
          } else {
            let seatWidth = 15;
            let seatHeight = 15;
            let seatGap = 5; // Промежуток между сидениями
            let rowGap = seatHeight; // Промежуток между рядами

            let targetRow = Math.floor(spectator.targetSeat / 20);
            let targetCol = spectator.targetSeat % 20;
            let targetX = startX + targetCol * (seatWidth + seatGap);
            let targetY = startY + targetRow * (seatHeight + seatGap + rowGap);

            if (Math.abs(spectator.x - targetX) > spectator.speed) {
              spectator.x += Math.sign(targetX - spectator.x) * spectator.speed;
            }
            if (Math.abs(spectator.y - targetY) > spectator.speed) {
              spectator.y += Math.sign(targetY - spectator.y) * spectator.speed;
            }
            spectator.y += (Math.random() - 0.5) * 5;

            // Условие для проверки, достиг ли зритель своего места
            if (
              Math.abs(spectator.x - targetX) < 3 &&
              Math.abs(spectator.y - targetY) < 3
            ) {
              spectator.isSeated = true; // Зритель занимает место
              seats[spectator.targetSeat] = true; // Место теперь занято

              // Условие для проверки коллизии зрителя и героя при занятии места
              if (!spectator.hasCollided && checkCollisionWithHero(spectator)) {
                spectator.color = "green"; // Окрашиваем в зеленый при коллизии
                spectator.hasCollided = true; // Отмечаем, что коллизия уже была
                collidedSpectators++; // Увеличиваем счетчик коллизий
              }

              // Теперь нет повторного увеличения коллизий для зрителей, которые уже вступили в коллизию
              // Учитываем зрителей, не имеющих коллизий с героем
              if (!spectator.hasCollided) {
                nonCollidedSpectators++;
              }
            }
          }
        }
      });
    }

    function updateHeroPosition() {
      if (keysPressed["ArrowLeft"]) hero.x -= hero.speed;
      if (keysPressed["ArrowRight"]) hero.x += hero.speed;
      if (keysPressed["ArrowUp"]) hero.y -= hero.speed;
      if (keysPressed["ArrowDown"]) hero.y += hero.speed;

      hero.x = Math.max(
        hero.radius,
        Math.min(canvas.width - hero.radius, hero.x)
      );
      hero.y = Math.max(
        hero.radius,
        Math.min(canvas.height - hero.radius, hero.y)
      );
      // Проверяем коллизии с врагом
      if (enemy && checkCollisionWithEnemy(hero, enemy)) {
        console.log("Ooops!");
      }
      // Проверяем коллизии с зрителями
      spectators.forEach((spectator) => {
        if (!spectator.isSeated && checkCollisionWithHero(spectator)) {
          spectator.color = "green"; // При коллизии перекрашиваем зрителя в зеленый
          collidedSpectators++; // Увеличиваем счетчик вошедших в коллизию зрителей
        }
      });
    }

    function checkCollisionWithSpectators(enemy) {
      let collidedSpectator = null;

      spectators.forEach((spectator) => {
        if (!spectator.isSeated) {
          if (enemy && enemy.x !== undefined && enemy.y !== undefined) {
            let dx = enemy.x - spectator.x;
            let dy = enemy.y - spectator.y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < enemy.radius + spectator.radius) {
              collidedSpectator = spectator;
              return;
            }
          }
          // console.log(
          //   "Enemy collided with spectator, starting following timer"
          // );
        }
      });

      return collidedSpectator;
    }

    // function updateEnemyPosition() {
    //   if (!enemy) return;

    //   // Находим направление к герою
    //   let dx = hero.x - enemy.x;
    //   let dy = hero.y - enemy.y;
    //   let distance = Math.sqrt(dx * dx + dy * dy);
    //   let vx = (dx / distance) * enemy.speed;
    //   let vy = (dy / distance) * enemy.speed;

    //   // Обновляем позицию врага, чтобы он преследовал героя
    //   enemy.x += vx;
    //   enemy.y += vy;

    //   // логика взаимодействия с зрителями и героем
    //   if (enemy.targetSpectator) {
    //     let dx = enemy.targetSpectator.x - enemy.x;
    //     let dy = enemy.targetSpectator.y - enemy.y;
    //     let distance = Math.sqrt(dx * dx + dy * dy);

    //     if (distance > 1) {
    //       // Движемся к целевому зрителю
    //       let vx = (dx / distance) * enemy.speed;
    //       let vy = (dy / distance) * enemy.speed;
    //       enemy.x += vx;
    //       enemy.y += vy;
    //     } else {
    //       // Зритель остановился, переключаемся на героя
    //       enemy.targetSpectator = null;
    //       startChasingHero(); // Возвращаемся к преследованию героя
    //     }
    //   }

    //   // Проверяем коллизию с зрителями при каждом обновлении позиции врага
    //   checkCollisionWithSpectators(enemy);
    // }
    // function updateEnemyPosition() {
    //   if (!enemy) return;

    //   // Находим направление к герою
    //   let dx = hero.x - enemy.x;
    //   let dy = hero.y - enemy.y;
    //   let distance = Math.sqrt(dx * dx + dy * dy);
    //   let vx = (dx / distance) * enemy.speed;
    //   let vy = (dy / distance) * enemy.speed;

    //   // Преследуем только тех зрителей, которые не вошли в коллизию с героем
    //   if (!checkCollisionWithSpectators(enemy)) {
    //     // Если враг не в коллизии с зрителями, обновляем его позицию относительно героя
    //     enemy.x += vx;
    //     enemy.y += vy;
    //   }
    // }
    // function updateEnemyPosition() {
    //   if (!enemy) return;

    //   // Находим направление к герою
    //   let dx = hero.x - enemy.x;
    //   let dy = hero.y - enemy.y;
    //   let distance = Math.sqrt(dx * dx + dy * dy);
    //   let vx = (dx / distance) * enemy.speed;
    //   let vy = (dy / distance) * enemy.speed;

    //   // Преследуем всех оранжевых зрителей, игнорируя зеленых
    //   for (let i = 0; i < spectators.length; i++) {
    //     const spectator = spectators[i];
    //     console.log("Spectator color:", spectator.color);
    //     if (spectator.color !== "green") {
    //       // Если зритель не зеленый, преследуем его
    //       console.log("Enemy is pursuing an orange spectator.");
    //       enemy.x += vx;
    //       enemy.y += vy;
    //       return; // Прерываем цикл, чтобы враг преследовал только одного зрителя за шаг
    //     }
    //   }
    //   console.log("No orange spectators found. Enemy is not pursuing.");
    // }
    function updateEnemyPosition() {
      if (!enemy) return; // Если враг не существует, выходим из функции

      // Находим направление к герою
      let dx = hero.x - enemy.x;
      let dy = hero.y - enemy.y;
      let distance = Math.sqrt(dx * dx + dy * dy);
      let vx = (dx / distance) * enemy.speed;
      let vy = (dy / distance) * enemy.speed;

      // Обновляем позицию врага, чтобы он преследовал героя
      enemy.x += vx;
      enemy.y += vy;

      // Проверяем, был ли зритель в коллизии с героем
      if (enemy.collidedWithHero) {
        // Если да, устанавливаем таймер на 4 секунды для игнорирования коллизий
        enemy.ignoreCollisionsTimer = 4000;
      } else {
        // Если нет, преследуем героя и сбрасываем таймер
        enemy.ignoreCollisionsTimer = 0;
      }

      // Уменьшаем таймер игнорирования коллизий, если он установлен
      if (enemy.ignoreCollisionsTimer > 0) {
        enemy.ignoreCollisionsTimer -= 1;
      }
    }

    function startChasingHero() {
      // console.log("Chasing hero now");
      if (enemy) {
        enemy.targetX = hero.x;
        enemy.targetY = hero.y;
      }
    }

    let followingSpectator = null;
    let timer = null;

    function followSpectator() {
      // console.log("Following timer started");
      if (followingSpectator) {
        enemy.x = followingSpectator.x;
        enemy.y = followingSpectator.y;
      }
    }

    function startFollowingTimer() {
      timer = setTimeout(() => {
        followingSpectator = null;
        // Здесь можно добавить код для возвращения к преследованию героя
        startChasingHero();
      }, 4000); // 4 секунды
    }

    function resetGame() {
      // Сбрасываем все переменные и счетчики в начальное состояние
      collidedSpectators = 0;
      nonCollidedSpectators = 0;
      heroCollisionCounter = 600; // Возвращаем счетчик коллизий героя с врагом к изначальному значению
      hero.x = canvas.width - 245; // Возвращаем героя в изначальную позицию
      hero.y = 350;
      enemy = null; // Убираем врага с поля

      // Очищаем массив сидений
      seats.fill(false);

      // Удаляем всех зрителей и перезапускаем их генерацию
      spectators = [];
      initializeSpectators();
    }

    function updateHeroCollisionCounter() {
      if (enemy && checkCollisionWithEnemy(hero, enemy)) {
        heroCollisionCounter--; // Уменьшаем счетчик при коллизии с врагом
        if (heroCollisionCounter <= 0) {
          // Если счетчик достиг нуля или меньше, перезапускаем игру
          resetGame();
        }
      }
    }

    function updateGame() {
      updateSpectators();
      updateHeroPosition();
      updateEnemyPosition();
      updateHeroCollisionCounter();

      if (nonCollidedSpectators >= 20 && !enemy) {
        createEnemy();
        console.log("Check!");
      }

      let collidedSpectator = checkCollisionWithSpectators(enemy);
      if (collidedSpectator) {
        followingSpectator = collidedSpectator;
        startFollowingTimer();
      }

      followSpectator();
    }

    function handleInput() {
      window.addEventListener("keydown", (e) => {
        keysPressed[e.key] = true;
      });

      window.addEventListener("keyup", (e) => {
        keysPressed[e.key] = false;
      });
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawScene();
      updateGame();
      // handleInput();
      requestAnimationFrame(gameLoop);
    }

    handleInput();
    initializeSpectators();
    requestAnimationFrame(gameLoop);
  </script>
</body>

</html>
